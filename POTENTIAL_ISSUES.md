# Потенциальные проблемы и подводные камни

Анализ кода на соответствие модели данных и возможные проблемы.

## ✅ Что работает правильно

1. **Схема БД соответствует моделям** - все таблицы и поля на месте
2. **Внешние ключи настроены** - связи между таблицами корректны
3. **Кодировка UTF-8 исправлена** - русские названия работают
4. **Миграции применяются автоматически** - при старте приложения

## ⚠️ Потенциальные проблемы

### 1. Несоответствие имен полей в документации

**Проблема:** В схеме указано `owner_id` для `shared_budgets`, но в модели используется `created_by`.

**Статус:** ✅ **НЕ проблема** - в коде используется правильное поле `created_by`.

**Проверка:**
```python
# В модели SharedBudget
created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
```

**Действие:** Обновить документацию, чтобы она соответствовала коду.

---

### 2. Производительность на сервере с 0.5ГБ RAM

**Проблема:** Сервер имеет ограниченные ресурсы (0.5ГБ RAM).

**Риски:**
- Медленные запросы при большом количестве данных
- Проблемы с пулом соединений (max_connections=20)
- Недостаток памяти для сложных запросов

**Уже исправлено:**
- ✅ `pool_size=5, max_overflow=5` - ограничен пул соединений
- ✅ `shared_buffers=64MB` - оптимизирована память PostgreSQL
- ✅ `max_connections=20` - ограничено на сервере

**Рекомендации:**
1. **Мониторинг использования памяти:**
   ```bash
   # На сервере БД
   ps aux | grep postgres
   free -h
   ```

2. **Ограничение выборок:**
   - Убедитесь, что все запросы используют `limit`
   - Избегайте загрузки всех записей сразу

3. **Индексы:**
   - Проверьте наличие индексов на часто используемых полях
   - Добавьте индексы, если их нет

---

### 3. N+1 Query Problem (Проблема множественных запросов)

**Проблема:** В некоторых местах код делает отдельные запросы для каждой записи.

**Примеры проблемных мест:**

#### В `transactions.py` (строки 196-214):
```python
for t in transactions:
    account = db.query(Account).filter(Account.id == t.account_id).first()  # N+1!
    category = db.query(Category).filter(Category.id == t.category_id).first()  # N+1!
    goal = db.query(Goal).filter(Goal.id == t.goal_id).first()  # N+1!
```

**Решение:** Использовать `joinedload` или `selectinload`:
```python
from sqlalchemy.orm import joinedload

transactions = db.query(Transaction)\
    .options(
        joinedload(Transaction.account),
        joinedload(Transaction.category),
        joinedload(Transaction.goal)
    )\
    .filter(...)\
    .all()
```

**Риск:** При большом количестве транзакций это может привести к множественным запросам и замедлению.

---

### 4. Отсутствие индексов на важных полях

**Проверьте наличие индексов:**

```sql
-- Проверка индексов
SELECT 
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename;
```

**Критичные индексы, которые должны быть:**
- `transactions.transaction_date` - для фильтрации по датам
- `transactions.user_id` - для фильтрации по пользователю
- `transactions.account_id` - для фильтрации по счету
- `categories.user_id` - для фильтрации категорий
- `accounts.user_id` - для фильтрации счетов

**Проверка:**
```bash
psql -h 195.43.142.121 -U finance_user -d finance_db -c "
SELECT 
    tablename,
    indexname
FROM pg_indexes
WHERE schemaname = 'public'
AND tablename IN ('transactions', 'accounts', 'categories')
ORDER BY tablename, indexname;
"
```

---

### 5. Проблемы с каскадными удалениями

**Проверьте настройки каскадных удалений:**

В моделях есть:
```python
accounts = relationship("Account", back_populates="owner", cascade="all, delete-orphan")
```

**Риск:** При удалении пользователя могут удалиться все его данные (счета, транзакции и т.д.).

**Рекомендация:** 
- Для production рассмотрите "мягкое удаление" (is_active=False)
- Или добавьте подтверждение перед удалением

---

### 6. Проблемы с типами данных (Numeric vs Float)

**Проблема:** В некоторых местах используется `float`, но в БД `Numeric(15,2)`.

**Примеры:**
- `initial_balance: float = 0.0` в схемах
- Но в БД: `Numeric(15, 2)`

**Риск:** Потеря точности при работе с деньгами.

**Уже исправлено в некоторых местах:**
```python
initial_balance=Decimal(str(account_data.initial_balance))
```

**Рекомендация:** Всегда использовать `Decimal` для денежных сумм.

---

### 7. Проблемы с транзакциями и блокировками

**Риск:** При одновременных запросах могут возникнуть блокировки.

**Особенно критично для:**
- Обновления баланса счетов
- Создания транзакций в общих бюджетах
- Обновления целей

**Рекомендация:**
- Использовать транзакции для критичных операций
- Добавить retry логику для deadlock ситуаций

---

### 8. Проблемы с shared_budget_id

**Проверьте логику:**

В `accounts` есть `shared_budget_id`, но также есть `user_id`. 

**Вопрос:** Кто является владельцем счета в общем бюджете?
- `user_id` - создатель счета
- `shared_budget_id` - общий бюджет

**Текущая логика:**
- Личные счета: `user_id` установлен, `shared_budget_id = NULL`
- Общие счета: `user_id` = создатель, `shared_budget_id` = ID бюджета

**Потенциальная проблема:** При удалении пользователя-создателя общий счет может стать "осиротевшим".

**Рекомендация:** 
- При удалении пользователя проверять, не является ли он единственным владельцем общего бюджета
- Или передавать владение другому участнику

---

### 9. Проблемы с nullable полями

**Проверьте обязательные поля:**

Некоторые поля могут быть `NULL`, но логика может ожидать значение:

- `category_id` в транзакциях - может быть NULL, но нужно проверять в коде
- `goal_id` в транзакциях - опционально
- `shared_budget_id` в accounts - опционально

**Рекомендация:** Всегда проверять на `None` перед использованием.

---

### 10. Проблемы с валидацией данных

**Риск:** Отсутствие валидации может привести к некорректным данным.

**Примеры:**
- Отрицательные суммы для доходов
- Даты в будущем для транзакций
- Несуществующие категории

**Рекомендация:** Добавить валидацию в Pydantic схемы.

---

### 11. Проблемы с производительностью запросов

**Потенциально медленные запросы:**

1. **Подсчет баланса счетов:**
   ```python
   # Может быть медленным при большом количестве транзакций
   transactions = db.query(Transaction).filter(Transaction.account_id == account_id).all()
   balance = sum(...)
   ```

2. **Агрегация по категориям:**
   - Группировка по категориям может быть медленной
   - Нужны индексы на `category_id` и `transaction_date`

**Рекомендация:**
- Использовать `SUM()` на уровне БД вместо Python
- Добавить материализованные представления для отчетов

---

### 12. Проблемы с кодировкой (частично исправлено)

**Статус:** ✅ Исправлено для создания категорий

**Остаточные риски:**
- Пользовательские данные (описания, названия)
- Импорт данных из других источников

**Рекомендация:** Всегда проверять кодировку при импорте данных.

---

## Чек-лист проверки

- [ ] Проверить индексы на критичных полях
- [ ] Исправить N+1 запросы в transactions.py
- [ ] Проверить использование Decimal для денежных сумм
- [ ] Добавить валидацию данных
- [ ] Проверить логику каскадных удалений
- [ ] Мониторить использование памяти на сервере
- [ ] Проверить производительность запросов
- [ ] Добавить обработку ошибок для блокировок

## Рекомендации по мониторингу

1. **Мониторинг производительности:**
   ```sql
   -- Медленные запросы
   SELECT * FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;
   ```

2. **Мониторинг подключений:**
   ```sql
   SELECT count(*) FROM pg_stat_activity WHERE datname = 'finance_db';
   ```

3. **Мониторинг размера БД:**
   ```sql
   SELECT pg_size_pretty(pg_database_size('finance_db'));
   ```

## Приоритетные исправления

1. **Высокий приоритет:**
   - Исправить N+1 запросы в transactions.py
   - Проверить и добавить недостающие индексы
   - Мониторинг использования памяти

2. **Средний приоритет:**
   - Валидация данных
   - Оптимизация запросов баланса
   - Обработка блокировок

3. **Низкий приоритет:**
   - Улучшение документации
   - Рефакторинг для читаемости






